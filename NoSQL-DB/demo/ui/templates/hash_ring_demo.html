{% extends "base.html" %}

{% block title %}Hash Ring Visualization - Distributed Database{% endblock %}
{% block demo_type %}hash_ring{% endblock %}

{% block header_title %}🎯 Consistent Hashing & Virtual Nodes{% endblock %}
{% block header_subtitle %}Visualize hash ring, virtual nodes, and key distribution in real-time{% endblock %}

{% block content %}
<!-- Hash Ring Visualization -->
<div class="card">
    <h3>🎯 Hash Ring Visualization</h3>
    <div id="hashRingContainer" style="text-align: center; padding: 20px; position: relative;">
        <svg id="hashRing" width="600" height="600" style="border: 1px solid #e5e7eb; border-radius: 8px; background: linear-gradient(to bottom, #f9fafb, #f3f4f6); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
            <!-- Hash ring will be drawn here -->
        </svg>
        <div id="ringControls" style="position: absolute; top: 10px; right: 10px; display: flex; gap: 5px;">
            <button class="btn btn-sm" onclick="zoomIn()" title="Zoom In" style="width: 30px; height: 30px; padding: 0;">➕</button>
            <button class="btn btn-sm" onclick="zoomOut()" title="Zoom Out" style="width: 30px; height: 30px; padding: 0;">➖</button>
            <button class="btn btn-sm" onclick="resetZoom()" title="Reset View" style="width: 30px; height: 30px; padding: 0;">🔄</button>
        </div>
    </div>
    <div style="text-align: center; margin-top: 20px;">
        <button class="btn btn-primary" onclick="initializeRing()">🔄 Initialize Ring</button>
        <button class="btn btn-secondary" onclick="refreshRing()" style="margin-left: 10px;">🔃 Refresh View</button>
        <button class="btn btn-info" onclick="testKeyDistribution()" style="margin-left: 10px;">🎲 Test Keys</button>
        <button class="btn btn-warning" onclick="animateKeyMigration()" style="margin-left: 10px;">🔄 Simulate Migration</button>
    </div>
</div>

<!-- Virtual Node Information -->
<div class="card">
    <h3>📊 Virtual Node Details</h3>
    <div id="virtualNodeInfo" style="padding: 20px;">
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="totalVNodes">0</div>
                <div class="stat-label">Total Virtual Nodes</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="vNodesPerPhysical">0</div>
                <div class="stat-label">VNodes per Physical</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="physicalNodes">0</div>
                <div class="stat-label">Physical Nodes</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="replicationFactor">0</div>
                <div class="stat-label">Replication Factor</div>
            </div>
        </div>
    </div>
</div>

<!-- Node Management -->
<div class="card">
    <h3>🔧 Cluster Management</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
        <div>
            <h4>Add Node</h4>
            <div class="form-group">
                <input type="text" class="form-input" id="newNodeAddress" 
                       placeholder="localhost:10002" value="localhost:10002">
            </div>
            <button class="btn btn-success" onclick="addNode()">➕ Add Node</button>
        </div>
        <div>
            <h4>Remove Node</h4>
            <select class="form-input" id="nodeToRemove">
                <option value="">Select node...</option>
            </select>
            <button class="btn btn-danger" onclick="removeNode()" style="margin-top: 10px;">➖ Remove Node</button>
        </div>
    </div>
</div>

<!-- Key Distribution -->
<div class="card">
    <h3>📈 Key Distribution Analysis</h3>
    <div id="keyDistribution" style="padding: 20px;">
        <canvas id="distributionChart" width="400" height="200"></canvas>
    </div>
    <div id="distributionStats" style="margin-top: 20px; display: none;">
        <h4>Distribution Statistics</h4>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="minKeys">0</div>
                <div class="stat-label">Min Keys/Node</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="maxKeys">0</div>
                <div class="stat-label">Max Keys/Node</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgKeys">0</div>
                <div class="stat-label">Avg Keys/Node</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stdDev">0%</div>
                <div class="stat-label">Std Deviation</div>
            </div>
        </div>
    </div>
</div>

<!-- Migration Analysis -->
<div class="card" id="migrationCard">
    <h3>🔄 Key Migration Analysis</h3>
    <div id="migrationInfo" style="padding: 20px;">
        <div class="alert alert-info">
            <strong>Migration Summary:</strong>
            <span id="migrationSummary">No recent cluster changes - perform node add/remove to see migration data</span>
        </div>
        <div class="stats-grid" style="margin-top: 20px;">
            <div class="stat-card">
                <div class="stat-value" id="keysMigrated">-</div>
                <div class="stat-label">Keys Migrated</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="migrationPercent">-</div>
                <div class="stat-label">Migration %</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="keysUnchanged">-</div>
                <div class="stat-label">Keys Unchanged</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalMigrations">-</div>
                <div class="stat-label">Migration Flows</div>
            </div>
        </div>
        
        <!-- Detailed Migration Breakdown -->
        <div id="migrationDetails" style="margin-top: 30px; display: none;">
            <h4 style="margin-bottom: 15px; color: #374151;">📊 Detailed Migration Breakdown</h4>
            <div id="migrationFlows" style="display: grid; gap: 15px;">
                <!-- Migration flows will be populated here -->
            </div>
        </div>
    </div>
</div>

<!-- Live Activity Log -->
<div class="card">
    <h3>📜 Activity Log</h3>
    <div id="activityLog" style="max-height: 300px; overflow-y: auto; padding: 15px; background: #f8f9fa; border-radius: 8px;">
        <div style="text-align: center; color: #6b7280;">
            Activity will appear here...
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
<script>
let currentRingData = null;
let distributionChart = null;

// Initialize demo
document.addEventListener('DOMContentLoaded', function() {
    console.log('🎯 Hash Ring Demo initialized');
    loadClusterNodes();
    initializeRing();
    
    // Close modal when clicking outside
    const modal = document.getElementById('migrationModal');
    if (modal) {
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeMigrationModal();
            }
        });
    }
});

// Initialize hash ring
function initializeRing() {
    fetch('/api/ring/initialize', { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage('Hash ring initialized', 'success');
                refreshRing();
            }
        })
        .catch(error => console.error('Error:', error));
}

// Refresh ring visualization
function refreshRing() {
    fetch('/api/ring/status')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                currentRingData = data.ring_data;
                updateVisualization(data.ring_data);
                updateStats(data.ring_data);
                if (data.ring_data.key_distribution) {
                    updateDistributionChart(data.ring_data.key_distribution);
                }
                if (data.ring_data.migration) {
                    updateMigrationInfo(data.ring_data.migration);
                }
            }
        })
        .catch(error => console.error('Error:', error));
}

// Update ring visualization with enhanced animations
function updateVisualization(ringData) {
    const svg = document.getElementById('hashRing');
    const width = 600;
    const height = 600;
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = 250;
    
    // Clear existing
    svg.innerHTML = '';
    
    // Add gradient definitions
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    
    // Ring gradient
    const ringGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
    ringGradient.setAttribute('id', 'ringGradient');
    ringGradient.innerHTML = `
        <stop offset="0%" stop-color="#e0e7ff" />
        <stop offset="100%" stop-color="#c7d2fe" />
    `;
    defs.appendChild(ringGradient);
    
    svg.appendChild(defs);
    
    // Draw outer ring with gradient
    const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    outerCircle.setAttribute('cx', centerX);
    outerCircle.setAttribute('cy', centerY);
    outerCircle.setAttribute('r', radius + 10);
    outerCircle.setAttribute('fill', 'none');
    outerCircle.setAttribute('stroke', 'url(#ringGradient)');
    outerCircle.setAttribute('stroke-width', '20');
    outerCircle.setAttribute('opacity', '0.3');
    svg.appendChild(outerCircle);
    
    // Draw main ring
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', centerX);
    circle.setAttribute('cy', centerY);
    circle.setAttribute('r', radius);
    circle.setAttribute('fill', 'none');
    circle.setAttribute('stroke', '#6366f1');
    circle.setAttribute('stroke-width', '2');
    svg.appendChild(circle);
    
    // Draw hash marks around the ring
    for (let i = 0; i < 72; i++) {
        const angle = (i / 72) * 2 * Math.PI;
        const innerR = radius - 5;
        const outerR = radius + 5;
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', centerX + innerR * Math.cos(angle));
        line.setAttribute('y1', centerY + innerR * Math.sin(angle));
        line.setAttribute('x2', centerX + outerR * Math.cos(angle));
        line.setAttribute('y2', centerY + outerR * Math.sin(angle));
        line.setAttribute('stroke', '#e5e7eb');
        line.setAttribute('stroke-width', '1');
        line.setAttribute('opacity', '0.5');
        svg.appendChild(line);
    }
    
    // Create groups for better organization
    const vnodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    vnodeGroup.setAttribute('id', 'vnodes');
    svg.appendChild(vnodeGroup);
    
    const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    labelGroup.setAttribute('id', 'labels');
    svg.appendChild(labelGroup);
    
    // Legend container
    const legendContainer = document.createElement('div');
    legendContainer.className = 'node-legend';
    legendContainer.id = 'nodeLegend';
    
    // Draw virtual nodes with animations
    if (ringData.virtual_node_mapping) {
        const colors = [
            { main: '#3b82f6', light: '#dbeafe', dark: '#1e40af' },
            { main: '#10b981', light: '#d1fae5', dark: '#047857' },
            { main: '#f59e0b', light: '#fef3c7', dark: '#b45309' },
            { main: '#ef4444', light: '#fee2e2', dark: '#b91c1c' },
            { main: '#8b5cf6', light: '#ede9fe', dark: '#6d28d9' }
        ];
        
        let colorIndex = 0;
        const nodeColors = {};
        
        for (const [physicalNode, vnodes] of Object.entries(ringData.virtual_node_mapping)) {
            const colorSet = colors[colorIndex % colors.length];
            nodeColors[physicalNode] = colorSet;
            colorIndex++;
            
            // Create legend item
            const legendItem = document.createElement('div');
            legendItem.className = 'legend-item';
            legendItem.innerHTML = `
                <div class="legend-dot" style="background: ${colorSet.main}"></div>
                <span>${physicalNode} (${vnodes.length} vnodes)</span>
            `;
            legendItem.onclick = () => highlightNode(physicalNode);
            legendContainer.appendChild(legendItem);
            
            vnodes.forEach((vnode, index) => {
                const angle = vnode.position * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                // Create gradient for each vnode
                const vnodeGradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                vnodeGradient.setAttribute('id', `vnode-gradient-${physicalNode}-${index}`);
                vnodeGradient.innerHTML = `
                    <stop offset="0%" stop-color="${colorSet.light}" />
                    <stop offset="100%" stop-color="${colorSet.main}" />
                `;
                defs.appendChild(vnodeGradient);
                
                // Draw virtual node with gradient
                const vnodeCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                vnodeCircle.setAttribute('cx', x);
                vnodeCircle.setAttribute('cy', y);
                vnodeCircle.setAttribute('r', '8');
                vnodeCircle.setAttribute('fill', `url(#vnode-gradient-${physicalNode}-${index})`);
                vnodeCircle.setAttribute('stroke', colorSet.main);
                vnodeCircle.setAttribute('stroke-width', '2');
                vnodeCircle.setAttribute('class', 'vnode');
                vnodeCircle.setAttribute('data-node', physicalNode);
                vnodeCircle.setAttribute('data-vnode', vnode.virtual_node_name);
                vnodeCircle.setAttribute('data-hash', vnode.hash);
                
                // Add hover effect
                vnodeCircle.onmouseenter = (e) => showTooltip(e, vnode.virtual_node_name, vnode.hash);
                vnodeCircle.onmouseleave = hideTooltip;
                
                vnodeGroup.appendChild(vnodeCircle);
                
                // Animate appearance
                vnodeCircle.style.opacity = '0';
                vnodeCircle.style.transform = `scale(0)`;
                setTimeout(() => {
                    vnodeCircle.style.transition = 'all 0.5s ease-out';
                    vnodeCircle.style.opacity = '1';
                    vnodeCircle.style.transform = 'scale(1)';
                }, index * 20);
            });
        }
        
        // Store node colors for later use
        window.nodeColors = nodeColors;
    }
    
    // Add legend to DOM
    const legendDiv = document.getElementById('nodeLegend');
    if (legendDiv) {
        legendDiv.remove();
    }
    document.querySelector('#hashRingContainer').appendChild(legendContainer);
    
    // Add center text
    const centerText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    centerText.setAttribute('x', centerX);
    centerText.setAttribute('y', centerY);
    centerText.setAttribute('text-anchor', 'middle');
    centerText.setAttribute('font-size', '24');
    centerText.setAttribute('font-weight', 'bold');
    centerText.setAttribute('fill', '#4b5563');
    centerText.innerHTML = `
        <tspan x="${centerX}" dy="-10">Hash Ring</tspan>
        <tspan x="${centerX}" dy="30" font-size="16" fill="#9ca3af">${ringData.node_count} nodes</tspan>
    `;
    svg.appendChild(centerText);
    
    logActivity('🎨 Ring visualization updated with animations');
}

// Show tooltip on hover
function showTooltip(event, vnodeName, hash) {
    const tooltip = document.getElementById('tooltip') || createTooltip();
    tooltip.innerHTML = `
        <strong>${vnodeName}</strong><br>
        Hash: ${hash}<br>
        Position: ${((hash / Math.pow(2, 32)) * 100).toFixed(2)}%
    `;
    
    const rect = event.target.getBoundingClientRect();
    tooltip.style.left = rect.left + rect.width / 2 - tooltip.offsetWidth / 2 + 'px';
    tooltip.style.top = rect.top - tooltip.offsetHeight - 10 + 'px';
    tooltip.classList.add('show');
}

// Hide tooltip
function hideTooltip() {
    const tooltip = document.getElementById('tooltip');
    if (tooltip) {
        tooltip.classList.remove('show');
    }
}

// Create tooltip element
function createTooltip() {
    const tooltip = document.createElement('div');
    tooltip.id = 'tooltip';
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);
    return tooltip;
}

// Highlight specific node
function highlightNode(nodeName) {
    const vnodes = document.querySelectorAll('.vnode');
    vnodes.forEach(vnode => {
        if (vnode.getAttribute('data-node') === nodeName) {
            vnode.classList.add('pulse');
            setTimeout(() => vnode.classList.remove('pulse'), 600);
        } else {
            vnode.style.opacity = '0.3';
            setTimeout(() => vnode.style.opacity = '1', 1000);
        }
    });
}

// Update statistics with animations
function updateStats(ringData) {
    animateStatUpdate('totalVNodes', ringData.virtual_nodes || 0);
    animateStatUpdate('vNodesPerPhysical', ringData.virtual_nodes_per_physical || 0);
    animateStatUpdate('physicalNodes', ringData.node_count || 0);
    animateStatUpdate('replicationFactor', ringData.replication_factor || 0);
}

// Animate stat value changes
function animateStatUpdate(elementId, newValue) {
    const element = document.getElementById(elementId);
    const currentValue = parseInt(element.textContent) || 0;
    
    if (currentValue === newValue) return;
    
    element.classList.add('updating');
    
    // Animate number change
    const duration = 500;
    const startTime = Date.now();
    const diff = newValue - currentValue;
    
    function updateNumber() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        const value = Math.round(currentValue + diff * easeOutCubic(progress));
        element.textContent = value;
        
        if (progress < 1) {
            requestAnimationFrame(updateNumber);
        } else {
            element.classList.remove('updating');
        }
    }
    
    requestAnimationFrame(updateNumber);
}

// Easing function for smooth animations
function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
}

// Update distribution chart
function updateDistributionChart(distribution) {
    const ctx = document.getElementById('distributionChart').getContext('2d');
    
    if (distributionChart) {
        distributionChart.destroy();
    }
    
    const labels = Object.keys(distribution.physical_node_distribution || {});
    const data = Object.values(distribution.physical_node_distribution || {});
    
    distributionChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Keys per Node',
                data: data,
                backgroundColor: '#3b82f6',
                borderColor: '#2563eb',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
    
    // Update stats
    if (distribution.distribution_stats && distribution.distribution_stats.physical_nodes) {
        const stats = distribution.distribution_stats.physical_nodes;
        document.getElementById('minKeys').textContent = stats.min_keys || 0;
        document.getElementById('maxKeys').textContent = stats.max_keys || 0;
        document.getElementById('avgKeys').textContent = (stats.avg_keys || 0).toFixed(1);
        
        // Calculate standard deviation percentage
        const avg = stats.avg_keys || 1;
        const maxDiff = Math.max(Math.abs(stats.max_keys - avg), Math.abs(avg - stats.min_keys));
        const stdDevPercent = (maxDiff / avg * 100).toFixed(1);
        document.getElementById('stdDev').textContent = stdDevPercent + '%';
        
        document.getElementById('distributionStats').style.display = 'block';
    }
}

// Update migration info
function updateMigrationInfo(migration) {
    if (migration && migration.migration_summary) {
        const summary = migration.migration_summary;
        const details = migration.migration_details || {};
        
        // Update values
        document.getElementById('keysMigrated').textContent = summary.keys_migrated || 0;
        document.getElementById('migrationPercent').textContent = (summary.migration_percentage || 0).toFixed(1) + '%';
        document.getElementById('keysUnchanged').textContent = summary.keys_unchanged || 0;
        document.getElementById('totalMigrations').textContent = Object.keys(details).length;
        
        // Update summary text
        if (summary.keys_migrated > 0) {
            document.getElementById('migrationSummary').textContent = 
                `${summary.keys_migrated} keys (${summary.migration_percentage.toFixed(1)}%) migrated after cluster change`;
        } else {
            document.getElementById('migrationSummary').textContent = 
                `No keys migrated - cluster topology unchanged`;
        }
        
        // Update detailed migration breakdown
        updateMigrationDetails(details);
        
        // Add visual indicator that this is fresh data
        const card = document.getElementById('migrationCard');
        card.style.borderLeft = '4px solid #10b981';
        setTimeout(() => {
            card.style.borderLeft = '';
        }, 3000);
    }
}

// Update detailed migration breakdown
function updateMigrationDetails(migrationDetails) {
    const detailsSection = document.getElementById('migrationDetails');
    const flowsContainer = document.getElementById('migrationFlows');
    
    if (Object.keys(migrationDetails).length > 0) {
        detailsSection.style.display = 'block';
        flowsContainer.innerHTML = '';
        
        // Sort migration flows by number of keys (descending)
        const sortedFlows = Object.entries(migrationDetails).sort((a, b) => b[1].count - a[1].count);
        
        sortedFlows.forEach(([flowKey, flowData]) => {
            const sourceNode = flowData.source_node;
            const destNode = flowData.destination_node;
            const keyCount = flowData.count;
            const keys = flowData.keys || [];
            
            // Create migration flow card
            const flowCard = document.createElement('div');
            flowCard.className = 'migration-flow-card';
            flowCard.style.cssText = `
                background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
                border: 1px solid #cbd5e1;
                border-radius: 12px;
                padding: 20px;
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            `;
            
            // Add hover effect
            flowCard.addEventListener('mouseenter', () => {
                flowCard.style.transform = 'translateY(-2px)';
                flowCard.style.boxShadow = '0 8px 25px rgba(0, 0, 0, 0.1)';
            });
            flowCard.addEventListener('mouseleave', () => {
                flowCard.style.transform = 'translateY(0)';
                flowCard.style.boxShadow = 'none';
            });
            
            flowCard.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: between; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; gap: 15px; flex: 1;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div class="node-badge source" style="
                                background: #fee2e2; 
                                color: #dc2626; 
                                padding: 6px 12px; 
                                border-radius: 20px; 
                                font-size: 12px; 
                                font-weight: 600;
                                border: 1px solid #fecaca;
                            ">
                                📤 ${sourceNode}
                            </div>
                            <div style="
                                font-size: 18px; 
                                color: #6b7280; 
                                font-weight: bold;
                            ">→</div>
                            <div class="node-badge destination" style="
                                background: #dcfce7; 
                                color: #16a34a; 
                                padding: 6px 12px; 
                                border-radius: 20px; 
                                font-size: 12px; 
                                font-weight: 600;
                                border: 1px solid #bbf7d0;
                            ">
                                📥 ${destNode}
                            </div>
                        </div>
                        <div style="
                            background: #3b82f6; 
                            color: white; 
                            padding: 8px 16px; 
                            border-radius: 25px; 
                            font-weight: bold; 
                            font-size: 16px;
                            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
                        ">
                            ${keyCount} keys
                        </div>
                    </div>
                    <button onclick="toggleKeyList('${flowKey.replace(/[^a-zA-Z0-9]/g, '_')}')" 
                            style="
                                background: #f1f5f9; 
                                border: 1px solid #cbd5e1; 
                                border-radius: 6px; 
                                padding: 6px 12px; 
                                cursor: pointer; 
                                font-size: 12px;
                                transition: all 0.2s;
                            "
                            onmouseover="this.style.background='#e2e8f0'"
                            onmouseout="this.style.background='#f1f5f9'">
                        View Keys
                    </button>
                </div>
                <div id="keylist_${flowKey.replace(/[^a-zA-Z0-9]/g, '_')}" style="display: none; margin-top: 15px;">
                    <div style="
                        background: #f8fafc; 
                        border: 1px solid #e2e8f0; 
                        border-radius: 8px; 
                        padding: 15px;
                        max-height: 200px;
                        overflow-y: auto;
                    ">
                        <div style="font-size: 13px; font-weight: 600; color: #374151; margin-bottom: 10px;">
                            Migrated Keys (${keyCount} total):
                        </div>
                        <div style="
                            display: flex; 
                            flex-wrap: wrap; 
                            gap: 6px;
                            font-family: 'Monaco', 'Menlo', monospace;
                            font-size: 11px;
                        ">
                            ${keys.slice(0, 50).map(key => `
                                <span style="
                                    background: #e0e7ff; 
                                    color: #3730a3; 
                                    padding: 3px 8px; 
                                    border-radius: 12px;
                                    border: 1px solid #c7d2fe;
                                ">${key}</span>
                            `).join('')}
                            ${keys.length > 50 ? `
                                <span style="
                                    background: #f3f4f6; 
                                    color: #6b7280; 
                                    padding: 3px 8px; 
                                    border-radius: 12px;
                                    font-style: italic;
                                ">... and ${keys.length - 50} more</span>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
            
            flowsContainer.appendChild(flowCard);
        });
    } else {
        detailsSection.style.display = 'none';
    }
}

// Toggle key list visibility
function toggleKeyList(flowId) {
    const keyList = document.getElementById(`keylist_${flowId}`);
    const button = event.target;
    
    if (keyList.style.display === 'none') {
        keyList.style.display = 'block';
        button.textContent = 'Hide Keys';
        button.style.background = '#dbeafe';
        button.style.color = '#1e40af';
    } else {
        keyList.style.display = 'none';
        button.textContent = 'View Keys';
        button.style.background = '#f1f5f9';
        button.style.color = '#374151';
    }
}

// Add node
function addNode() {
    const address = document.getElementById('newNodeAddress').value;
    if (!address) {
        showMessage('Please enter node address', 'error');
        return;
    }
    
    fetch('/api/node/add', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ address: address })
    })
    .then(response => response.json())
    .then(data => {
        console.log('Add node response:', data);
        if (data.success) {
            showMessage(data.message, 'success');
            logActivity(`Added node: ${address}`);
            loadClusterNodes();
            
            // Update migration info immediately and show card
            if (data.migration) {
                updateMigrationInfo(data.migration);
            }
            
            // Refresh ring visualization and key distribution after a short delay
            setTimeout(() => {
                fetch('/api/ring/status')
                    .then(response => response.json())
                    .then(ringData => {
                        if (ringData.success) {
                            updateVisualization(ringData.ring_data);
                            updateStats(ringData.ring_data);
                            if (ringData.ring_data.key_distribution) {
                                updateDistributionChart(ringData.ring_data.key_distribution);
                            }
                            // Don't call updateMigrationInfo here - preserve existing migration data
                        }
                    })
                    .catch(error => console.error('Error refreshing ring:', error));
            }, 2000);
        } else {
            showMessage(data.error, 'error');
        }
    })
    .catch(error => showMessage(error.message, 'error'));
}

// Remove node
function removeNode() {
    const address = document.getElementById('nodeToRemove').value;
    if (!address) {
        showMessage('Please select a node', 'error');
        return;
    }
    
    if (!confirm(`Remove node ${address} from cluster?`)) {
        return;
    }
    
    fetch('/api/node/remove', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ address: address })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showMessage(data.message, 'success');
            logActivity(`Removed node: ${address}`);
            loadClusterNodes();
            
            // Update migration info immediately and show card
            if (data.migration) {
                updateMigrationInfo(data.migration);
            }
            
            // Refresh ring visualization and key distribution after a short delay
            setTimeout(() => {
                fetch('/api/ring/status')
                    .then(response => response.json())
                    .then(ringData => {
                        if (ringData.success) {
                            updateVisualization(ringData.ring_data);
                            updateStats(ringData.ring_data);
                            if (ringData.ring_data.key_distribution) {
                                updateDistributionChart(ringData.ring_data.key_distribution);
                            }
                            // Don't call updateMigrationInfo here - preserve existing migration data
                        }
                    })
                    .catch(error => console.error('Error refreshing ring:', error));
            }, 2000);
        } else {
            showMessage(data.error, 'error');
        }
    })
    .catch(error => showMessage(error.message, 'error'));
}

// Test key distribution with visual feedback
function testKeyDistribution() {
    const numKeys = prompt('How many test keys?', '1000');
    if (!numKeys) return;
    
    // Show loading state
    const testBtn = event.target;
    const originalText = testBtn.innerHTML;
    testBtn.innerHTML = '<span class="spinner"></span> Testing...';
    testBtn.disabled = true;
    
    // Visualize test keys on the ring
    visualizeTestKeys(parseInt(numKeys));
    
    fetch('/api/keys/test', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ num_keys: parseInt(numKeys) })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showMessage(`✅ Tested distribution of ${data.keys_tested} keys`, 'success');
            updateDistributionChart(data.distribution);
            logActivity(`🎲 Tested ${data.keys_tested} key distribution`);
            
            // Animate distribution results
            animateDistributionResults(data.distribution);
        }
    })
    .catch(error => showMessage(error.message, 'error'))
    .finally(() => {
        testBtn.innerHTML = originalText;
        testBtn.disabled = false;
        clearKeyVisualization();
    });
}

// Visualize test keys on the ring
function visualizeTestKeys(numKeys) {
    const svg = document.getElementById('hashRing');
    const centerX = 300;
    const centerY = 300;
    const radius = 250;
    
    const keyGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    keyGroup.setAttribute('id', 'testKeys');
    
    // Generate random key positions
    for (let i = 0; i < Math.min(numKeys, 50); i++) {
        const angle = Math.random() * 2 * Math.PI;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        
        const keyDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        keyDot.setAttribute('cx', x);
        keyDot.setAttribute('cy', y);
        keyDot.setAttribute('r', '3');
        keyDot.setAttribute('fill', '#ef4444');
        keyDot.setAttribute('class', 'key-marker');
        keyDot.style.opacity = '0';
        
        keyGroup.appendChild(keyDot);
        
        // Animate appearance
        setTimeout(() => {
            keyDot.style.transition = 'all 0.5s ease-out';
            keyDot.style.opacity = '0.6';
        }, i * 20);
    }
    
    svg.appendChild(keyGroup);
}

// Clear key visualization
function clearKeyVisualization() {
    const keyGroup = document.getElementById('testKeys');
    if (keyGroup) {
        // Fade out animation
        const keys = keyGroup.querySelectorAll('.key-marker');
        keys.forEach((key, index) => {
            setTimeout(() => {
                key.style.opacity = '0';
                key.style.transform = 'scale(0)';
            }, index * 10);
        });
        
        setTimeout(() => keyGroup.remove(), 500);
    }
}

// Animate distribution results
function animateDistributionResults(distribution) {
    if (distribution.physical_node_distribution) {
        // Flash nodes based on their key count
        const maxKeys = Math.max(...Object.values(distribution.physical_node_distribution));
        
        Object.entries(distribution.physical_node_distribution).forEach(([node, count]) => {
            const intensity = count / maxKeys;
            flashNode(node, intensity);
        });
    }
}

// Flash a node with intensity
function flashNode(nodeName, intensity) {
    const vnodes = document.querySelectorAll(`[data-node="${nodeName}"]`);
    vnodes.forEach(vnode => {
        const originalR = vnode.getAttribute('r');
        vnode.style.transition = 'all 0.3s ease-out';
        vnode.setAttribute('r', 12 + intensity * 8);
        
        setTimeout(() => {
            vnode.setAttribute('r', originalR);
        }, 300);
    });
}

// Load cluster nodes
function loadClusterNodes() {
    fetch('/api/cluster/health')
        .then(response => response.json())
        .then(data => {
            const select = document.getElementById('nodeToRemove');
            select.innerHTML = '<option value="">Select node...</option>';
            
            Object.keys(data.nodes).forEach(node => {
                const option = document.createElement('option');
                option.value = node;
                option.textContent = `${node} (${data.nodes[node].status})`;
                select.appendChild(option);
            });
        });
}

// Log activity with enhanced styling
function logActivity(message) {
    const log = document.getElementById('activityLog');
    const entry = document.createElement('div');
    const timestamp = new Date().toLocaleTimeString();
    
    // Determine message type and icon
    let icon = '📝';
    let borderColor = '#e5e7eb';
    if (message.includes('Added')) {
        icon = '➕';
        borderColor = '#10b981';
    } else if (message.includes('Removed')) {
        icon = '➖';
        borderColor = '#ef4444';
    } else if (message.includes('Test')) {
        icon = '🎲';
        borderColor = '#f59e0b';
    } else if (message.includes('initialized')) {
        icon = '🚀';
        borderColor = '#3b82f6';
    } else if (message.includes('updated')) {
        icon = '🎨';
        borderColor = '#8b5cf6';
    }
    
    entry.style.cssText = `
        padding: 12px;
        margin-bottom: 8px;
        background: white;
        border-radius: 8px;
        border-left: 4px solid ${borderColor};
        opacity: 0;
        transform: translateX(-20px);
        transition: all 0.3s ease;
    `;
    
    entry.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
            <span style="font-size: 18px;">${icon}</span>
            <div style="flex: 1;">
                <span style="color: #6b7280; font-size: 12px;">${timestamp}</span>
                <div style="color: #1f2937; margin-top: 2px;">${message}</div>
            </div>
        </div>
    `;
    
    if (log.children[0] && log.children[0].textContent.includes('Activity will appear')) {
        log.innerHTML = '';
    }
    
    log.insertBefore(entry, log.firstChild);
    
    // Animate entry
    requestAnimationFrame(() => {
        entry.style.opacity = '1';
        entry.style.transform = 'translateX(0)';
    });
    
    // Keep only last 20 entries
    while (log.children.length > 20) {
        const lastEntry = log.lastChild;
        lastEntry.style.opacity = '0';
        lastEntry.style.transform = 'translateX(20px)';
        setTimeout(() => lastEntry.remove(), 300);
    }
}

// Socket.IO handlers
socket.on('ring_update', function(data) {
    updateVisualization(data);
    updateStats(data);
});

socket.on('key_distribution_update', function(data) {
    updateDistributionChart(data.distribution);
});

// Zoom controls
let currentZoom = 1;
const maxZoom = 2;
const minZoom = 0.5;

function zoomIn() {
    if (currentZoom < maxZoom) {
        currentZoom += 0.2;
        applyZoom();
    }
}

function zoomOut() {
    if (currentZoom > minZoom) {
        currentZoom -= 0.2;
        applyZoom();
    }
}

function resetZoom() {
    currentZoom = 1;
    applyZoom();
}

function applyZoom() {
    const svg = document.getElementById('hashRing');
    const content = svg.querySelector('g') || svg;
    content.style.transform = `scale(${currentZoom})`;
    content.style.transformOrigin = 'center';
}

// Animate key migration
function animateKeyMigration() {
    const svg = document.getElementById('hashRing');
    const vnodes = svg.querySelectorAll('.vnode');
    
    if (vnodes.length < 2) {
        showMessage('Need at least 2 nodes for migration simulation', 'warning');
        return;
    }
    
    // Create migration particles
    const migrationGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    migrationGroup.setAttribute('id', 'migrations');
    
    for (let i = 0; i < 10; i++) {
        const sourceNode = vnodes[Math.floor(Math.random() * vnodes.length)];
        const targetNode = vnodes[Math.floor(Math.random() * vnodes.length)];
        
        if (sourceNode === targetNode) continue;
        
        const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        particle.setAttribute('r', '4');
        particle.setAttribute('fill', '#ef4444');
        particle.setAttribute('opacity', '0.8');
        
        const sourceCx = sourceNode.getAttribute('cx');
        const sourceCy = sourceNode.getAttribute('cy');
        particle.setAttribute('cx', sourceCx);
        particle.setAttribute('cy', sourceCy);
        
        migrationGroup.appendChild(particle);
        
        // Animate migration
        setTimeout(() => {
            particle.style.transition = 'all 1s ease-in-out';
            particle.setAttribute('cx', targetNode.getAttribute('cx'));
            particle.setAttribute('cy', targetNode.getAttribute('cy'));
            particle.style.opacity = '0';
        }, i * 100);
    }
    
    svg.appendChild(migrationGroup);
    
    // Clean up
    setTimeout(() => migrationGroup.remove(), 2000);
    
    logActivity('🔄 Simulated key migration animation');
}

// Don't auto-refresh - it overwrites migration data
// User can manually refresh with the button if needed
</script>

<style>
.stats-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 20px;
    margin-bottom: 20px;
}

.stat-card {
    text-align: center;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    transition: transform 0.2s, box-shadow 0.2s;
}

.stat-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.stat-value {
    font-size: 28px;
    font-weight: bold;
    color: #1f2937;
    margin-bottom: 5px;
    transition: color 0.3s;
}

.stat-value.updating {
    color: #3b82f6;
}

.stat-label {
    font-size: 14px;
    color: #6b7280;
}

.alert {
    padding: 15px;
    margin-bottom: 20px;
    border-radius: 8px;
}

.alert-info {
    background: #dbeafe;
    color: #1e40af;
    border: 1px solid #93c5fd;
}

/* Virtual node styles */
.vnode {
    cursor: pointer;
    transition: all 0.3s ease;
}

.vnode:hover {
    filter: brightness(1.2);
    stroke-width: 3;
}

.vnode-label {
    font-size: 11px;
    fill: #4b5563;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
}

.vnode:hover + .vnode-label {
    opacity: 1;
}

/* Physical node legend */
.node-legend {
    display: flex;
    justify-content: center;
    gap: 30px;
    margin-top: 20px;
    flex-wrap: wrap;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    cursor: pointer;
    padding: 5px 10px;
    border-radius: 20px;
    transition: background 0.2s;
}

.legend-item:hover {
    background: #f3f4f6;
}

.legend-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    transition: transform 0.2s;
}

.legend-item:hover .legend-dot {
    transform: scale(1.3);
}

/* Key visualization */
.key-marker {
    cursor: pointer;
    opacity: 0.8;
    transition: all 0.3s;
}

.key-marker:hover {
    opacity: 1;
    transform: scale(1.2);
}

.key-path {
    stroke: #ef4444;
    stroke-width: 2;
    fill: none;
    stroke-dasharray: 5,5;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
}

.key-marker:hover ~ .key-path {
    opacity: 0.5;
}

/* Animation for ring updates */
@keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.5); opacity: 0.5; }
    100% { transform: scale(1); opacity: 1; }
}

.pulse {
    animation: pulse 0.6s ease-out;
}

/* Migration animation */
@keyframes migrate {
    0% { transform: translateX(0); opacity: 1; }
    50% { opacity: 0.3; }
    100% { transform: translateX(20px); opacity: 0; }
}

.migrating {
    animation: migrate 1s ease-out;
}

/* Activity log improvements */
#activityLog > div {
    transition: all 0.3s ease;
    border-left: 3px solid transparent;
}

#activityLog > div:hover {
    border-left-color: #3b82f6;
    background: #f0f9ff !important;
    transform: translateX(5px);
}

/* Tooltip */
.tooltip {
    position: absolute;
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 13px;
    pointer-events: none;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s;
}

.tooltip.show {
    opacity: 1;
}

.tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: rgba(0, 0, 0, 0.9) transparent transparent transparent;
}

/* Loading spinner */
.spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(59, 130, 246, 0.3);
    border-radius: 50%;
    border-top-color: #3b82f6;
    animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Button animations */
.btn {
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.btn::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.3);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
}

.btn:active::after {
    width: 300px;
    height: 300px;
}
</style>
{% endblock %}