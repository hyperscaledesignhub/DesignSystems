{% extends "base.html" %}

{% block title %}Node Failure Demo - Distributed Database{% endblock %}
{% block demo_type %}node_failure{% endblock %}

{% block header_title %}🔧 Node Failure & Recovery Demo{% endblock %}
{% block header_subtitle %}Demonstrating cluster resilience, fault tolerance, and automatic data synchronization{% endblock %}

{% block content %}
<!-- Cluster Overview -->
<div class="card">
    <h3>🏗️ Cluster Status & Node Control</h3>
    <div class="cluster-grid" id="clusterGrid">
        <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #6b7280;">
            Click "🔄 Refresh" to load cluster status
        </div>
    </div>
    
    <!-- Simplified cluster health display -->
    <div id="clusterHealth" style="margin-top: 15px; padding: 10px; border-radius: 8px; text-align: center; font-size: 14px;">
        Quorum Status: <span id="quorumStatus" style="font-weight: bold;">-</span>
        <button class="btn btn-secondary" onclick="loadClusterStatus()" style="margin-left: 10px; font-size: 12px; padding: 4px 8px;">
            🔄 Refresh
        </button>
        <button class="btn btn-warning" onclick="clearStaleErrors()" style="margin-left: 5px; font-size: 12px; padding: 4px 8px;">
            🧹 Fix Cluster Errors
        </button>
    </div>
</div>

<!-- Fault Tolerance Testing -->
<div class="card">
    <h3>🧪 Fault Tolerance Testing</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
        
        <!-- Manual Operations -->
        <div style="border: 1px solid #e5e7eb; border-radius: 8px; padding: 15px;">
            <h4>Manual Operations</h4>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button class="btn btn-success" onclick="generateTestData()" id="generateBtn">
                    📝 Generate Data
                </button>
                <button class="btn btn-primary" onclick="performTestWrite()" id="writeBtn">
                    ✏️ Test Write
                </button>
                <button class="btn btn-secondary" onclick="performTestRead()" id="readBtn">
                    📖 Test Read
                </button>
            </div>
            <div style="font-size: 12px; color: #6b7280;">
                Generate test data, then test read/write operations to verify fault tolerance
            </div>
        </div>
        
        <!-- Continuous Traffic -->
        <div style="border: 1px solid #e5e7eb; border-radius: 8px; padding: 15px;">
            <h4>Continuous Traffic</h4>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button class="btn btn-warning" onclick="startContinuousTraffic()" id="trafficStartBtn">
                    🚀 Start Traffic
                </button>
                <button class="btn" onclick="stopContinuousTraffic()" id="trafficStopBtn" style="background: #ef4444; color: white;" disabled>
                    🛑 Stop Traffic
                </button>
            </div>
            <div style="font-size: 12px; color: #6b7280;">
                Generate continuous read/write operations to simulate real load
            </div>
        </div>
    </div>
    
    <!-- Operation Results -->
    <div id="operationResults" style="margin-top: 20px;">
        <h4>📊 Latest Operation Results</h4>
        <div id="operationsList" style="max-height: 200px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 8px; padding: 15px;">
            <div style="text-align: center; color: #6b7280; padding: 20px;">
                Perform operations to see results here...
            </div>
        </div>
    </div>
</div>

<!-- Node Synchronization Status -->
<div class="card" id="syncStatusCard" style="display: none;">
    <h3>🔄 Data Synchronization Progress</h3>
    <div id="syncDetails">
        <div id="syncProgress" style="margin-bottom: 15px;">
            <!-- Sync progress will be shown here -->
        </div>
        <div id="syncLog" style="max-height: 200px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 8px; padding: 15px;">
            <!-- Sync operations will be logged here -->
        </div>
    </div>
</div>

<!-- Live Operations Timeline -->
<div class="card">
    <h3>📈 Live Operations Timeline</h3>
    <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 15px;">
        <div style="font-size: 14px; color: #6b7280;">Real-time log of all database operations</div>
        <button class="btn btn-secondary" onclick="clearOperationsTimeline()" style="font-size: 12px; padding: 4px 8px;">
            Clear Timeline
        </button>
    </div>
    <div id="operationsTimeline" style="max-height: 400px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 8px; padding: 15px;">
        <div style="text-align: center; color: #6b7280; padding: 20px;">
            Operations timeline will appear here as they are executed...
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
    let operationsCount = 0;
    let monitoringInterval = null;
    let continuousTrafficActive = false;
    
    // Initialize demo
    document.addEventListener('DOMContentLoaded', function() {
        console.log('🔧 Node failure demo initialized');
        // Don't auto-load cluster status - wait for user to click refresh
        // This prevents cluster stress on page load
        
        // Show initial message
        const syncStatus = document.getElementById('quorumStatus');
        syncStatus.textContent = 'Click Refresh to check';
    });
    
    // Load cluster status with detailed information
    function loadClusterStatus() {
        fetch('/api/cluster_status')
            .then(response => response.json())
            .then(data => updateClusterDisplay(data))
            .catch(error => console.error('Error loading cluster status:', error));
    }
    
    // Update cluster display
    function updateClusterDisplay(data) {
        const clusterGrid = document.getElementById('clusterGrid');
        const nodes = data.nodes;
        
        clusterGrid.innerHTML = '';
        
        Object.keys(nodes).forEach(nodeId => {
            const node = nodes[nodeId];
            const nodeCard = document.createElement('div');
            nodeCard.className = `node-card ${node.status}`;
            
            let statusIcon = '✅';
            let statusColor = '#16a34a';
            let statusText = 'Healthy';
            let actionButton = '';
            
            if (node.status === 'failed') {
                statusIcon = '❌';
                statusColor = '#dc2626';
                statusText = 'Failed';
                actionButton = `<button class="btn-small btn-success" onclick="restoreNode('${nodeId}')">🔄 Restore</button>`;
            } else if (node.status === 'offline') {
                statusIcon = '⚪';
                statusColor = '#6b7280';
                statusText = 'Offline';
                actionButton = `<button class="btn-small btn-success" onclick="restoreNode('${nodeId}')">🔄 Restore</button>`;
            } else if (node.status === 'syncing') {
                statusIcon = '🔄';
                statusColor = '#f59e0b';
                statusText = 'Syncing';
                actionButton = `<span style="font-size: 12px; color: #f59e0b;">Synchronizing data...</span>`;
            } else {
                actionButton = `<button class="btn-small btn-danger" onclick="simulateNodeFailure('${nodeId}')">🔴 Fail Node</button>`;
            }
            
            nodeCard.innerHTML = `
                <div class="node-header">
                    <div class="node-icon">${statusIcon}</div>
                    <h4>${nodeId.toUpperCase()}</h4>
                    <div class="node-address">${node.address}</div>
                </div>
                <div class="node-details">
                    <div style="color: ${statusColor}; font-weight: 600; margin-bottom: 8px;">
                        Status: ${statusText}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 10px;">
                        Data Count: ${node.data_count || 0}
                        ${node.lag_count ? `<br><span style="color: #f59e0b;">Lag: ${node.lag_count} items behind</span>` : ''}
                    </div>
                    <div class="node-actions">
                        ${actionButton}
                    </div>
                </div>
            `;
            
            clusterGrid.appendChild(nodeCard);
        });
        
        // Update simplified health summary
        const faultTolerance = data.fault_tolerance;
        document.getElementById('quorumStatus').textContent = faultTolerance.quorum_available ? '✅ Available' : '❌ Lost';
        
        // Update cluster health card color
        const healthCard = document.getElementById('clusterHealth');
        if (faultTolerance.quorum_available) {
            healthCard.style.background = '#f0fdf4';
            healthCard.style.border = '2px solid #22c55e';
        } else {
            healthCard.style.background = '#fef2f2';
            healthCard.style.border = '2px solid #ef4444';
        }
    }
    
    // Simulate node failure
    function simulateNodeFailure(nodeId) {
        if (confirm(`Are you sure you want to simulate failure for ${nodeId}? This will make the node unavailable for operations.`)) {
            fetch('/api/simulate_node_failure', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({node_id: nodeId})
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(`${nodeId} failure simulated - testing fault tolerance!`, 'warning');
                } else {
                    showMessage(`Failed to simulate failure: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                showMessage(`Error: ${error.message}`, 'error');
            });
        }
    }
    
    // Restore failed node
    function restoreNode(nodeId) {
        fetch('/api/restore_node', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({node_id: nodeId})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(`${nodeId} is being restored and will sync data automatically`, 'success');
                document.getElementById('syncStatusCard').style.display = 'block';
            } else {
                showMessage(`Failed to restore node: ${data.error}`, 'error');
            }
        })
        .catch(error => {
            showMessage(`Error: ${error.message}`, 'error');
        });
    }
    
    // Generate test data
    function generateTestData() {
        const btn = document.getElementById('generateBtn');
        btn.disabled = true;
        btn.textContent = '📝 Generating...';
        
        fetch('/api/generate_test_data', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(`Generated ${data.generated_count} test data items successfully!`, 'success');
            } else {
                showMessage(`Failed to generate data: ${data.error}`, 'error');
            }
            
            btn.disabled = false;
            btn.textContent = '📝 Generate Data';
        })
        .catch(error => {
            showMessage(`Error: ${error.message}`, 'error');
            btn.disabled = false;
            btn.textContent = '📝 Generate Data';
        });
    }
    
    // Perform test write
    function performTestWrite() {
        const btn = document.getElementById('writeBtn');
        btn.disabled = true;
        btn.textContent = '✏️ Writing...';
        
        fetch('/api/test_writes_reads', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({type: 'write'})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(`Write successful: ${data.key} = ${data.value} (${data.successful_writes}/${data.total_attempts} nodes)`, 'success');
            } else {
                showMessage(`Write failed: ${data.error}`, 'error');
            }
            
            btn.disabled = false;
            btn.textContent = '✏️ Test Write';
        })
        .catch(error => {
            showMessage(`Error: ${error.message}`, 'error');
            btn.disabled = false;
            btn.textContent = '✏️ Test Write';
        });
    }
    
    // Perform test read
    function performTestRead() {
        const btn = document.getElementById('readBtn');
        btn.disabled = true;
        btn.textContent = '📖 Reading...';
        
        fetch('/api/test_writes_reads', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({type: 'read'})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(`Read successful: ${data.key} (${data.successful_reads}/${data.total_attempts} nodes, ${data.consistent ? 'consistent' : 'inconsistent'})`, 'success');
            } else {
                showMessage(`Read failed: ${data.error}`, 'error');
            }
            
            btn.disabled = false;
            btn.textContent = '📖 Test Read';
        })
        .catch(error => {
            showMessage(`Error: ${error.message}`, 'error');
            btn.disabled = false;
            btn.textContent = '📖 Test Read';
        });
    }
    
    // Start continuous traffic
    function startContinuousTraffic() {
        fetch('/api/start_continuous_traffic', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                continuousTrafficActive = true;
                document.getElementById('trafficStartBtn').disabled = true;
                document.getElementById('trafficStopBtn').disabled = false;
                showMessage('Continuous traffic started - simulating real-world load!', 'info');
            } else {
                showMessage(`Failed to start traffic: ${data.error}`, 'error');
            }
        })
        .catch(error => {
            showMessage(`Error: ${error.message}`, 'error');
        });
    }
    
    // Stop continuous traffic
    function stopContinuousTraffic() {
        fetch('/api/stop_continuous_traffic', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        })
        .then(response => response.json())
        .then(data => {
            continuousTrafficActive = false;
            document.getElementById('trafficStartBtn').disabled = false;
            document.getElementById('trafficStopBtn').disabled = true;
            showMessage('Continuous traffic stopped', 'info');
        })
        .catch(error => {
            showMessage(`Error: ${error.message}`, 'error');
        });
    }
    
    // Clear stale errors and fix cluster
    function clearStaleErrors() {
        showMessage('🧹 Fixing cluster errors and reinitializing data...', 'info');
        
        fetch('/api/clear_stale_errors', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(`✅ Fixed cluster: cleared ${data.cleared_nodes} nodes, reinitialized ${data.reinitialized_keys} keys`, 'success');
                // Refresh status after fixing
                setTimeout(loadClusterStatus, 3000);
            } else {
                showMessage('❌ Failed to fix cluster errors', 'error');
            }
        })
        .catch(error => {
            showMessage(`Error: ${error.message}`, 'error');
        });
    }
    
    // Clear operations timeline
    function clearOperationsTimeline() {
        const timeline = document.getElementById('operationsTimeline');
        timeline.innerHTML = `
            <div style="text-align: center; color: #6b7280; padding: 20px;">
                Operations timeline cleared - new operations will appear here...
            </div>
        `;
        operationsCount = 0;
        showMessage('Operations timeline cleared', 'info');
    }
    
    // Add operation to timeline
    function addOperationToTimeline(operation) {
        const timeline = document.getElementById('operationsTimeline');
        
        // Clear placeholder if it exists
        if (timeline.children.length === 1 && timeline.textContent.includes('Operations timeline will appear')) {
            timeline.innerHTML = '';
        }
        
        const operationDiv = document.createElement('div');
        const timestamp = new Date(operation.timestamp * 1000).toLocaleTimeString();
        const isWrite = operation.type === 'write';
        
        let statusColor, statusIcon, statusText;
        if (isWrite) {
            if (operation.successful_writes > 0) {
                statusColor = operation.quorum_achieved ? '#16a34a' : '#f59e0b';
                statusIcon = operation.quorum_achieved ? '✅' : '⚠️';
                statusText = operation.quorum_achieved ? 'WRITE SUCCESS' : 'PARTIAL WRITE';
            } else {
                statusColor = '#dc2626';
                statusIcon = '❌';
                statusText = 'WRITE FAILED';
            }
        } else {
            if (operation.successful_reads > 0) {
                statusColor = operation.consistent ? '#16a34a' : '#f59e0b';
                statusIcon = operation.consistent ? '✅' : '⚠️';
                statusText = operation.consistent ? 'READ SUCCESS' : 'INCONSISTENT READ';
            } else {
                statusColor = '#dc2626';
                statusIcon = '❌';
                statusText = 'READ FAILED';
            }
        }
        
        operationDiv.style.cssText = `
            padding: 12px; 
            border: 2px solid ${statusColor}; 
            background: ${statusColor}15; 
            margin-bottom: 8px; 
            border-radius: 8px;
        `;
        
        operationDiv.innerHTML = `
            <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 8px;">
                <div style="font-weight: 600; color: ${statusColor};">
                    ${statusIcon} ${statusText}
                </div>
                <div style="font-size: 12px; color: #6b7280;">${timestamp}</div>
            </div>
            <div style="font-size: 14px; margin-bottom: 8px;">
                ${isWrite ? `Key: ${operation.key} | Value: ${operation.value}` : `Key: ${operation.key}`}
                ${isWrite ? ` | Success: ${operation.successful_writes}/${operation.nodes_attempted}` : ` | Success: ${operation.successful_reads}/${operation.nodes_attempted}`}
            </div>
            <div style="font-size: 12px; color: #6b7280;">
                ${isWrite ? 
                    (operation.quorum_achieved ? '🛡️ Fault tolerance: Write replicated across multiple nodes' : '⚠️ Warning: Insufficient replication for full fault tolerance') :
                    (operation.consistent ? '🛡️ Data consistency: All nodes returned same value' : '⚠️ Notice: Some nodes may be out of sync')
                }
            </div>
        `;
        
        timeline.insertBefore(operationDiv, timeline.firstChild);
        
        // Keep only last 20 operations
        while (timeline.children.length > 20) {
            timeline.removeChild(timeline.lastChild);
        }
        
        operationsCount++;
    }
    
    // Socket.IO event handlers
    socket.on('node_status_change', function(data) {
        console.log('Node status changed:', data);
        showMessage(`${data.node_id}: ${data.message}`, data.status === 'failed' ? 'error' : 'info');
        // Manual refresh only
    });
    
    socket.on('operation_result', function(data) {
        addOperationToTimeline(data);
    });
    
    socket.on('sync_progress', function(data) {
        const syncCard = document.getElementById('syncStatusCard');
        const syncProgress = document.getElementById('syncProgress');
        
        syncCard.style.display = 'block';
        
        const percentage = Math.round((data.synced_count / data.total_count) * 100);
        
        syncProgress.innerHTML = `
            <div style="margin-bottom: 10px;">
                <strong>Syncing ${data.node_id}:</strong> ${data.synced_count}/${data.total_count} items (${percentage}%)
            </div>
            <div style="background: #e5e7eb; border-radius: 8px; height: 8px; margin-bottom: 10px;">
                <div style="background: #3b82f6; height: 8px; border-radius: 8px; width: ${percentage}%; transition: width 0.3s;"></div>
            </div>
            <div style="font-size: 12px; color: #6b7280;">
                Currently syncing: ${data.current_key}
            </div>
        `;
    });
    
    socket.on('sync_complete', function(data) {
        const syncProgress = document.getElementById('syncProgress');
        
        syncProgress.innerHTML = `
            <div style="color: #16a34a; font-weight: 600; margin-bottom: 10px;">
                ✅ ${data.node_id} sync completed successfully!
            </div>
            <div style="background: #16a34a; height: 8px; border-radius: 8px; margin-bottom: 10px;"></div>
            <div style="font-size: 12px; color: #15803d;">
                Synced ${data.synced_count}/${data.total_count} items - node is now fully up to date
            </div>
        `;
        
        showMessage(`${data.node_id} synchronization completed - node is back online!`, 'success');
        
        // Hide sync card after a few seconds
        setTimeout(() => {
            document.getElementById('syncStatusCard').style.display = 'none';
        }, 5000);
    });
    
    socket.on('sync_failed', function(data) {
        const syncProgress = document.getElementById('syncProgress');
        
        syncProgress.innerHTML = `
            <div style="color: #dc2626; font-weight: 600; margin-bottom: 10px;">
                ❌ ${data.node_id} sync failed
            </div>
            <div style="background: #dc2626; height: 8px; border-radius: 8px; margin-bottom: 10px;"></div>
            <div style="font-size: 12px; color: #dc2626;">
                Error: ${data.error}
            </div>
        `;
        
        showMessage(`${data.node_id} sync failed: ${data.error}`, 'error');
    });
</script>

<style>
.cluster-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin-bottom: 20px;
}

.node-card {
    border: 2px solid #e5e7eb;
    border-radius: 12px;
    padding: 20px;
    transition: all 0.3s ease;
    background: white;
}

.node-card.healthy {
    border-color: #22c55e;
    background: #f0fdf4;
}

.node-card.failed {
    border-color: #ef4444;
    background: #fef2f2;
}

.node-card.offline {
    border-color: #6b7280;
    background: #f9fafb;
}

.node-card.syncing {
    border-color: #f59e0b;
    background: #fffbeb;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

.node-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.node-header {
    text-align: center;
    margin-bottom: 15px;
}

.node-icon {
    font-size: 24px;
    margin-bottom: 8px;
}

.node-header h4 {
    margin: 0 0 5px 0;
    font-size: 16px;
    font-weight: 700;
}

.node-address {
    font-size: 12px;
    color: #6b7280;
}

.node-details {
    text-align: center;
}

.node-actions {
    margin-top: 12px;
}

.btn-small {
    padding: 4px 8px;
    font-size: 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
}

.btn-small.btn-danger {
    background: #ef4444;
    color: white;
}

.btn-small.btn-success {
    background: #22c55e;
    color: white;
}


#operationsTimeline::-webkit-scrollbar {
    width: 6px;
}

#operationsTimeline::-webkit-scrollbar-track {
    background: #f1f5f9;
}

#operationsTimeline::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 3px;
}

.live-indicator {
    color: #ef4444;
    font-size: 12px;
    animation: blink 1.5s infinite;
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0.3; }
}
</style>
{% endblock %}